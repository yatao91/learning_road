#### 针对es存储浮点数类型时, 对其进行数值聚合出现精度问题的处理

##### 1. es支持的浮点数类型

| 类型           | max_value | min_value      | 特点                     |
| -------------- | --------- | -------------- | ------------------------ |
| `double`       | 2-1074    | (2-2-52)·21023 | 64位双精度浮点数         |
| `float`        | 2-149     | (2-2-23)·2127  | 32位单精度浮点数         |
| `half_float`   | 2-24      | 65504          | 16位半精度浮点数         |
| `scaled_float` | --        | --             | 具有固定缩放因子的浮点数 |

> `double` `float` `half_float`三种类型认为 `-0.0`和`+0.0`是不同的值. 进行`term`查找`-0.0`不会匹配`+0.0`, `range`范围查询时, 上边界是`-0.0`, 不会匹配`+0.0`. 反之亦然.

> 其中`scaled_float`类型, 比如价格只需要精确到分, price为57.34的字段缩放因子为100, 存起来就是5734.
>
> 优先考虑使用待缩放因子的`scaled_float`浮点类型.

> `scaled_float`所需的额外的参数:
>
> `scaling_factor` : 缩放因子在编码value时使用. 原始值会乘以缩放因子在进行索引的时候, 并将多余的value进行round(四舍五入). 比如: 缩放因子为100, 存储2.34为234, 存储2.345为235.
>
> 较大的缩放因子可以提高精度, 但同时会增加空间开销. 

##### 2. 实际业务使用中所遇到的问题

> 在使用业务应用过程中, 对待小数, 均使用`float`类型进行存储, 但实际业务中, 会进行`sum`求和类型的聚合, 对数值进行求和的操作. 在`sum`聚合的过程中, 则会出现`float`类型精度失真的情况. 

##### 3. 解决方案

> 经过对`scaled_float`类型的测试发现, 可以使用此类型作为小数类型的存储方式, 以提高聚合计算时的精度问题.
>
> `mapping`如下:
>
> ```json
> {
>     "mappings": {
>         "my_type": {
>             "properties": {
>                 "num_field": {
>                     "type": "scaled_float",
>                     "scaling_factor": 100
>                 }
>             }
>         }
>     }
> }
> ```

