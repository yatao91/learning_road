## Bloom Filter

#### 1.简介

> 1970年由布隆提出.
>
> 实际上是一个很长的二进制向量和一系列随机映射函数.
>
> 布隆过滤器可以用于检索一个元素是否在一个集合中. 
>
> 优点: 空间效率和查询时间远超一般算法.
>
> 缺点: 有一定的误识别率和删除困难.

#### 2.使用场景

> - 爬虫中: 判断一个URL是否被爬取过
> - 垃圾邮件过滤功能
>
> > 共同问题: 查看一个元素是否在有大量数据的池子中.
>
> 通常做法可以使用: 数组/链表/树/哈希表等数据结构来实现. 当数据量很大的时候, 就会有问题, 消耗的内存将会呈线性增长, 最终达到瓶颈. 
>
> 例如: 使用哈希表存储一亿个垃圾email地址的消耗. 首先, 哈希函数将一个email地址映射成8字节信息指纹;考虑到哈希表存储效率通常小于50%(哈希冲突/碰撞); 因此消耗的内存: 8 * 2 * 1亿 字节 = 1.6G内存. 

#### 3.哈希函数

> - 哈希函数简介
>
>   哈希函数, 又成散列函数/散列算法(`Hash function`): 是一种从任何一种数据中创建小的数字"指纹"的方法. 散列函数把消息或数据压缩成摘要, 使得数据量变小, 将数据的格式固定下来. 
>
>   该函数将数据打乱混合, 重新创建一个叫做**散列值**的指纹(hash values).
>
> - 哈希函数性质
>
>   1. 哈希函数具有**确定性**: 如果两个散列值是不同的(根据同一哈希函数), 那么这两个散列值的原始输入也是不相同的. 
>   2. **散列碰撞**: 如果两个散列值相同, 两个输入值很可能是相同的, 但也可能不同. 
>
> - 哈希函数原理图: 
>
>   ![1558169788384](C:\Users\46081\AppData\Roaming\Typora\typora-user-images\1558169788384.png)

#### 4.布隆过滤器原理--数据结构

> 布隆过滤器是一个`bit`向量或者说`bit`数组. 如下图所示:
>
> ![img](https://pic3.zhimg.com/80/v2-530c9d4478398718c15632b9aa025c36_hd.jpg)
>
> 如果我们要映射一个值到布隆过滤器中，我们需要使用**多个不同的哈希函数**生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：
>
> ![img](https://pic4.zhimg.com/80/v2-a0ee721daf43f29dd42b7d441b79d227_hd.jpg)
>
> Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：
>
> ![img](https://pic3.zhimg.com/80/v2-c0c20d8e06308aae1578c16afdea3b6a_hd.jpg)
>
> 值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，**说明没有任何一个值映射到这个 bit 位上**，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” **存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。**
>
> 这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。

#### 5.添加元素

> - 将要添加的元素给k个哈希函数
> - 得到对应于位数组上的k个位置
> - 将这k个位置设为1

#### 6.查询元素是否存在

> - 将要查询的元素给k个哈希函数
> - 得到对应于位数组上的k个位置
> - 如果k个位置有一个为0，则肯定不在集合中
> - 如果k个位置全部为1，则可能在集合中

## **支持删除么**

目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。

如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。

## **如何选择哈希函数个数和布隆过滤器长度**

很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。

另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。

![img](https://pic4.zhimg.com/80/v2-05d4a17ec47911d9ff0e72dc788d5573_hd.jpg)k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率

如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：

![img](https://pic1.zhimg.com/80/v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_hd.jpg)

如何推导这个公式这里只是提一句，因为对于使用来说并没有太大的意义，你让一个高中生来推会推得很快。k 次哈希函数某一 bit 位未被置为 1 的概率为：

![(1-\frac{1}{m})^{k}](https://www.zhihu.com/equation?tex=%281-%5Cfrac%7B1%7D%7Bm%7D%29%5E%7Bk%7D)

插入n个元素后依旧为 0 的概率和为 1 的概率分别是：

![\left( 1-\frac{1}{m} \right)^{nk}](https://www.zhihu.com/equation?tex=%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk%7D) ![1- \left( 1-\frac{1}{m} \right)^{nk }](https://www.zhihu.com/equation?tex=1-+%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk+%7D)

标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 1，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定

![\left[ 1- \left( 1-\frac{1}{m} \right)^{nk} \right]^{k}\approx\left( 1-e^{-kn/m} \right)^{k}](https://www.zhihu.com/equation?tex=%5Cleft%5B+1-+%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk%7D+%5Cright%5D%5E%7Bk%7D%5Capprox%5Cleft%28+1-e%5E%7B-kn%2Fm%7D+%5Cright%29%5E%7Bk%7D)

## **最佳实践**

常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。

**大Value拆分**

Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。

拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。



#### 引用

> [详解布隆过滤器的原理，使用场景和注意事项](https://zhuanlan.zhihu.com/p/43263751)
>
> [布隆过滤器(Bloom Filter)的原理和实现](https://www.jianshu.com/p/88c6ac4b38c8)
>
> [散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)
>
> [布隆过滤器](https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)
>
> [使用 BloomFilter 布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重](https://blog.csdn.net/tianyaleixiaowu/article/details/74721877)

