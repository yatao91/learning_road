## 链表

#### 简介

> 链表是一种线性表，即线性表的链式存储结构。
>
> 链表的特点是：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
>
> 对链表的数据元素而言：除了需要存储本身的数据之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）
>
> **数据域**：存储数据元素信息的域
>
> **指针域**：存储直接后继位置的域，存储的信息称之为指针或链
>
> **结点(Node)**：数据域 + 指针域
>
> **单链表**：n个结点链组成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域。单链表就是通过每个结点的指针域将线性表的数据元素按逻辑次序链接在一起。
>
> ![](http://ww3.sinaimg.cn/large/006tNc79ly1g3hdyvi0z4j30tx0a2whi.jpg)

#### 基本结构

> **头指针**：链表中第一个结点的存储位置叫做头指针
>
> 线性链表的最后一个结点指针为"空"(通常用NULL表示)
>
> ![](http://ww2.sinaimg.cn/large/006tNc79gy1g3he3504yyj30yx09awii.jpg)
>
> **头结点**：为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域不存储任何信息，不过也可以存储如线性表的长度等附加信息，头结点的指针域指向第一个结点的指针。
>
> ![](http://ww4.sinaimg.cn/large/006tNc79gy1g3he6h44u4j3108080jvd.jpg)
>
> 头指针与头结点的异同点：
>
> - 头指针
>   - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针；
>   - 头指针具有标识作用，所以常用头指针冠以链表的名字
>   - 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。
> - 头结点
>   - 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可以存放链表的长度）
>   - 有了头结点，对在第一元素结点前插入结点和删除第一个结点，其操作与其他结点的操作就统一了。
>   - 头结点不一定是链表必要元素

#### 单链表读取

> 获取链表第i个数据的思路：
>
> 1. 声明一个结点p指向链表的第一个结点，初始化j从1开始；
> 2. 当j < i时，遍历链表， 让p的指针向后移动，不断指向下一结点，j累加1；
> 3. 若到链表末尾p为空，则说明第i个元素不存在；
> 4. 否则查找成功，返回结点p的数据。
>
> 此算法的时间复杂度取决于i的位置，i=1时，O(1); i=n时，最坏时间复杂度为O(n)。
>
> 读取的核心思想：**工作指针后移**

#### 单链表的插入和删除

###### 1. 单链表的插入

> - 将一结点s插入到结点p和p->next之间（表头表尾的特殊情况操作是相同的）
>
>   s->next = p->next：让p的后继结点改成s的后继结点
>
>   p->next = s：把结点s变成p的后继结点
>
>   **注意**：以上两部顺序不可调换。如果调换了将变成如下情形：
>
>   p->next = s
>
>   s->next = p->next 就相当于 s->next=s
>
>   这样的插入操作就是失败的
>
> 单链表第i个数据插入结点的算法思路：
>
> 1. 声明一结点p指向链表第一个结点，初始化j从1开始
> 2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
> 3. 若到链表末尾p为空，则说明第i个元素不存在
> 4. 否则查找成功，在系统中生成一个空结点s
> 5. 将数据元素e赋值给 s->data
> 6. 单链表的插入标准语句 s->next = p->next; p->next = s
> 7. 返回插入成功

###### 2. 单链表的删除

> 假设删除q结点，就是将它的前继结点的指针绕过，指向它的后继结点即可。
>
> ![](http://ww4.sinaimg.cn/large/006tNc79gy1g3hgv32f8kj30ne08fmzt.jpg)
>
> 即需要一步即可：
>
> p->next = p->next->next, 用q来取代p->next
>
> 即是：
>
> q = p->next; p->next = q->next
>
> 单链表第i个数据删除结点的算法思路：
>
> 1. 声明一结点p指向链表第一个结点，初始化j从1开始
> 2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点， j累加1
> 3. 若到链表末尾p为空，则说明第i个元素不存在
> 4. 否则查找成功，将要删除的结点p->next赋值给q
> 5. 单链表的删除标准语句 p->next=q->next
> 6. 将q结点中的数据赋值给e，作为返回
> 7. 释放q结点
> 8. 返回成功

###### 3. 插入删除时间复杂度

> 插入或删除一个元素，时间复杂度都是O(n)
>
> 相对单链表和线性表，如果系统从第i个位置，插入10个元素。
>
> 对于线性表而言，每次插入都需要移动n-i个元素。每次都是O(n)
>
> 对于单链表而言，只需要第一次找到第i个位置的指针，此次为O(n)，接下来只是简单的通过赋值移动指针而已，时间复杂度都是O(1).
>
> 所以：**对于插入或删除数据越频繁的操作，单链表的效率优势就越明显**

#### 单链表的整表创建

> 创建单链表的过程：就是一个动态生成链表的过程。即从"空表"的初始状态起，依次建立各元素结点，并逐个插入链表。
>
> 单链表整表创建的算法思路（头插法）：
>
> 1. 声明一结点p和计数器变量i
> 2. 初始化一空链表L
> 3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表
> 4. 循环：
>    - 生成一新结点赋值给p
>    - 随机生成一数字赋值给p的数据域p->data
>    - 将p插入到头结点与前一新结点之前

